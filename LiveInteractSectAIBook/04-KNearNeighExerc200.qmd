---
title: "Interactive Exercises for k-Nearest Neighbors: Predict Wine Color"
format: live-html


webr:
  packages: ['dplyr', 'rsample', 'janitor',  'recipes', 
             'yardstick','parsnip','workflows', 'kknn'] # Auto-install packages in the browser

engine: knitr
---


{{< include .././_extensions/r-wasm/live/_knitr.qmd >}}
{{< include .././_extensions/r-wasm/live/_gradethis.qmd >}}

<span style="color: red; font-weight: bold;">Your browser is loading R and all needed packages. That can take a while (about 1:00 - 2:00 minutes). Please be patient. You can see the progress in the right lower corner of your browser.</span>

In what follows, you will develop your own *k-Nearest Neighbors* model to predict the color of wines based on chemical properties. In contrast to the previous section, you will extend the analysis to use all chemical properties available in the wine dataset.

Below you can see all variables available in the wine dataset. The first variable $WineColor$ is the outcome variable, followed by the predictor variables that indicate the chemical properties of a wine. The  variable $Quality$ which reflect how consumers rated the quality of the wines and which is in the original dataset, is omitted. This variable is not a chemical property and is likely irrelevant for predicting a wine's color. 
```{webr}
#| label: ex_all
#| include: false
DataWineOrg<- read.csv("https:///econ.lange-analytics.com/RData/Datasets/WineData.csv")
set.seed(876)

DataWine = DataWineOrg |> 
           clean_names("upper_camel") |> 
           select(-Quality) |> 
           rename(Sulfur=TotalSulfurDioxide) |> 
           mutate(WineColor=as.factor(WineColor))

Split7030=initial_split(DataWine, prop=0.7, strata=WineColor)

DataTrain=training(Split7030)

DataTest=testing(Split7030) 

RecipeWine=recipe(WineColor~., data=DataTrain) |>
           step_naomit() |> 
           step_normalize(all_predictors()) 

ModelDesignKNN=nearest_neighbor(neighbors=4, weight_func="rectangular") |>
               set_engine("kknn") |> 
               set_mode("classification")

WFModelWine=workflow() |> 
            add_recipe(RecipeWine) |>
            add_model(ModelDesignKNN) |> 
            fit(DataTrain)

DataTestWithPred=augment(WFModelWine, DataTest)
```

```{webr}
#| exercise: ex_0
#| exercise.setup: ex_all
#| autorun: true
#| runbutton: false
head(DataWine)
```

## Exercise 1 

The code block below uses the already loaded wine dataset ('DataWine'). The variable $WineColor$ was coded as a `factor` data type as required by the *k-Nearest Neighbors* algorithm.

After the random number generator has been initialized, the data are split into training and testing data (see Section \@ref(KNearNeigh-Data) for details).

**Now it is your turn:** Please complete the two commands that extract training and testing data from the split to assign them to the data frames `DataTrain` and `DataTest`.

```{webr}
#| exercise: ex_1
#| exercise.setup: ex_all
set.seed(876)
Split7030=initial_split(DataWine, prop=0.7, strata=WineColor)

DataTrain=______(______)
DataTest=______(______)
```

::: { .hint exercise="ex_1"}
**Here is a hint:**

The command to extract the *training data* from the initial split is called `training()`. 
The one for the *testing data* is called `testing()`.

The initial split is stored in the R object `Split7030`. 
The latter includes the data frame `DataWine` together 
with an indicator for each observation, if it 
belongs to the *training data* or the `testing data`.

`Split7030` is the only argument needed in the commands `training()` and `testing()`.
:::

::: {.solution exercise="ex_1"}
**Here is the solution:**

```{webr}
#| exercise: ex_1
#| solution: true
set.seed(876)
Split7030=initial_split(DataWine, prop=0.7, strata=WineColor)

DataTrain=training(Split7030) #<1>
DataTest=testing(Split7030)  #<2>
```                                

1. The commands `training()`  generates   the  *training data*. `Split7030` determines which observations from `DataWine` are sorted into the *training data*
2. The commands `testing()`  generates   the  *testing data*. `Split7030` determines which observations from `DataWine` are sorted into the *testing data*
:::

```{webr}
#| exercise: ex_1
#| check: true
gradethis::grade_this_code()
```

## Exercise 2 

This exercise requires some preparation. By executing the code block below, you will create the **recipe** and the results will be saved into the *R* object `RecipeWine`. The command `tidy` outputs the result as a data frame that is easy to read:

```{webr}
#| exercise: ex_2prep1
#| exercise.setup: ex_all
RecipeWine=recipe(WineColor~., data=DataTrain) |> 
           step_naomit() |> 
           step_normalize(all_predictors())
tidy(RecipeWine)
```

You also need to prepare the **model-design**. When you execute the commands below *model-design* are also the same as before. When you execute the code block below, the *model-design* will be created and saved into the *R* object `ModelDesignKNN`. The command  `tidy` outputs the result as a data frame that is easy to read:

```{webr}
#| exercise: ex_2prep2
#| exercise.setup: ex_all
ModelDesignKNN=nearest_neighbor(neighbors=4, 
                                weight_func="rectangular") |>
               set_engine("kknn") |> 
               set_mode("classification")

tidy(ModelDesignKNN)
```

You are now tasked with adding the *recipe* and the *model-design* to a **workflow** and then fitting the workflow to the training data. Note that the *recipe* `RecipeWine`, the *model-design* `ModelDesignKNN`, and the data frame `DataTrain` have already been loaded in the background. Please complete the code block below and execute it.

```{webr}
#| exercise: ex_2
#| exercise.setup: ex_all
WFModelWine=workflow() |> 
            add_recipe(______) |>
            add_model(______) |> 
            fit(______)

tidy(WFModelWine)
```

::: { .hint exercise="ex_2"}
**Here is a hint:**

The *recipe* (`RecipeWine`) and the *model-design* ('ModelDesignKNN') from the previous exercises  can be reused and have been loaded in the background. The only need to be added
 to the *workflow*.


To fit the workflow and make it a *fitted workflow model*, we
use the fit() command. The data are used to fit
are always the training data (in this case  'DataTrain')
:::

::: {.solution exercise="ex_2"}
**Here is the solution:**

```{webr}
#| exercise: ex_2
#| solution: true
WFModelWine=workflow() |> 
            add_recipe(RecipeWine) |>
            add_model(ModelDesignKNN) |> 
            fit(DataTrain)

tidy(WFModelWine)
```
:::

```{webr}
#| exercise: ex_2
#| check: true
gradethis::grade_this_code()
```
